# Unfile
Unfile determines how easy it would be to replace a file from an external source.
This might be useful in a few scenarios:
+ You have a drive from an old system and you want to retrieve your files without having to sift through system files or program assets.
+ You run a backup and want to keep the documents or save games that various programs create without having to find all the directories to which such programs save thier files.

## Theory
The idea behind Unfile is quite simple. Files that are important to keep are likely to only be seen on a single system, and files that can be easily replaced will be seen on many systems. Each file is analyzed by hashing it, and maintaining a count of the number of times that hash has ever been seen. If the count is high, the file is likely less important and can be replaced. If the count is low, the file is likely to be hard to replace and should therefore be kept.

## The Server
The first half of Unfile is the server. The server is written in C for performance. The server maintains and dispenses information about the hashes it has been sent. It can be told to increment the count associated with a hash, or it can be queried about the count of a particular hash without incrementing it.
The server stores the counts in a binary tree where each bit from right to left determines which branch of the tree is taken. When there are no more 1 bits to the left of the current bit, the current node is the node you are searching for.

## The Client
The second half of Unfile is the client. The client is written in Python for cross platform support. The client scans a directory recursively and hashes each file it encounters. The hashes are then sent to the server where they are by default incremented, and the counts for each hash are returned to the client. The client will then copy the files whose hash is over a certain threshold to the destination directory.

## Pitfalls
+ In order to be effective, the server must have a decent number of systems scanned in order to determine which files are important. Untill the server has enough data, it will not produce good or meaningful results.
+ There will be false positives whenever a file is unique, but not important. Any file that is generated by the users actions, but is regenerated at will falls into this category. A browser cache stored on the disk, indices for an IDE's autocompletion function, and the swapfile are all examples of files that are unique, but you would not want to keep.
+ At the moment the server is not hosted anywhere.
